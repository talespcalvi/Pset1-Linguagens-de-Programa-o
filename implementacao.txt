Implementação do PSET1 
Aluno: Tales Paiva Calvi
Turma: CC4M

	Inicialmente para a implementação do pset1 é pedido para utilizar o filtro de inversão, entretanto antes de realmente trabalhar na função para isso, denominada 'invertida()' é necessário corrigir erros de outras funções que agem para que essa funcione. A primeira coisa que se percebe é que a função 'aplicar_por_pixel()' já possui um erro de identação na linha onde diz 'for y in range(resultado.altura), esse erro é corrigido acertando o espaçamento da linha 'resultado.set_pixel(y, x, nova_cor) colocando a alinhada com a linha acima. Trabalhando dentro desse loop ainda é necessário corrigir outro erro, nessa mesma linha que possuia um erro de identação era necessário corrigir os parâmetros que a função recebe, nesse caso a ordem de x e y estavam invertida sendo assim corrigida para 'resultado.set_pixel(x, y, nova_cor). Outro erro já claro dentro dessa função está no parâmetros que os loops for recebem, onde recebem 'resultado.largura' e 'resultado.altura', então é trocado 'resultado' por 'self' em ambos para que funcione corretamente, dentro desse loop também são apagadas as linhas 'nova_cor = ""' e 'y = ""' pois ambas não são necessárias para o funcionamento do código. Por fim nessa função, existe um erro na primeira linha dela onde a posição de largura e altura estão invertidas, então na linha onde está escrito 'resultado = Imagem.nova(self.altura, self.largura)' é corrigido para 'resultado = Imagem.nova(self.largura, self.altura)'.

	Partindo agora para as funções acima, na função 'get_pixel' é necessário implementar a fórmula de row-major-order para garantir que os pixels sejam percorridos corretamente ao uso da função, então no return é adcionado essa fórmula, assim indo de 'return self.pixels[x, y]' para 'return self.pixels[(self.largura * y) + x]'. O mesmo é necessário fazer na função 'set_pixel' indo de 'self.pixels[x, y] = c' para 'self.pixels[(self.largura * y) + x] = c'.
	Podemos agora finalmente trabalhar na função 'invertida()', essa que é uma função bem simples e que estava implementada, a única correção necessária a fazer é acertar o valor '256' para '255' que é o intervalo correto de tons de cinza, assim de 'return self.aplicar_por_pixel(lambda c: 256 - c)' vai para 'return self.aplicar_por_pixel(lambda c: 255 - c)'.

	Após isso é pedido para implementar uma função para utilizar a correlação de kernels com as imagens que é a forma que se aplica outros filtros a elas, para isso é preciso implementar uma função que aplique a fórmula da correlação aos pixels da imagem, essa fórmula no caso multiplica o valor presente em uma posição de uma matriz(kernel) ao valor do pixel de mesma posição em um parte secionada da imagem, faz isso para cada pixel da parte secionada e soma os resultados para gerar um valor novo, para assim alterar o valor de apenas um dos pixels da imagem, ou seja, para uma matriz(kernel) 3x3, seria selecionado um pixel da imagem para ser alterado, os pixels em volta dele seriam utilizados, para que forme uma matriz 3x3 também e dessa forma o valor do pixel de posição (1,1) será multiplicado pelo valor da matriz(kernel) de posição (1,1), e assim respectivamente para cada pixel da parte secionada da imagem da matriz(kernel), esses valores serão somados e o resultado dessa soma será o valor do novo pixel da imagem.
	Para implementar essa função chamada 'aplicar_correlação' essa irá receber a própria instância de si mesma e um kernel, sendo esse escrito especificando primeiro suas medidas (3,3 ou 2,2) e logo após sua composição. Após isso assim, como as funções anteriores ela retornará uma imagem que será criada da mesma forma 'resultado = Imagem.nova(self.largura, self.altura)', também é necessário calcular o tamanho do kernel com 'tamanho_kernel = len(kernel) // 2' e depois, e depois é feito o uso de loops para percorrer a imagem e também o kernel utilizado, no caso com o cálculo do tamanho do kernel feito antes é garantido que no loop as partes da imagem que serão secionadas para aplicar a correlação terão as mesmas medidas do kernel. Ainda falando do loop para percorrer a imagem, ele é feito assim como na função 'aplicar_pixel()' 'for x in range(resultado.largura):' e dentro desse for 'for y in range(resultado.altura):', dentro desse for setado que a soma é igual a zero para garantir que o resultado saia corretamente por meio de 'soma = 0.0' e é feito mais um loop como o anterior para percorrer o kernel, feito da seguinte forma 'for i in range(len(kernel)):' e dentro desse for 'for j in range(len(kernel[i])):', dentro desse for são calculadas as coordenadas dos pixel vizinhos por meio de 'pixel_x = x - tamanho_kernel + j' e 'pixel_y = y - tamanho_kernel + i' e é calculado produto entre o valor do pixel e o valor correspondente do kernel por meio de 'soma += self.acertar_borda(pixel_x, pixel_y) * kernel[i][j] '. Por fim no loop para o x é setado por meio da função 'set_pixel' aplicada a imagem resultada criada no começo da função.
 